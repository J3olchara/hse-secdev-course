# ADR-001: Обработка ошибок в формате RFC 7807

Дата: 2025-01-22
Статус: Accepted

## Context

В нашем API сервисе wishlist нужно стандартизировать обработку ошибок чтобы клиенты могли понять что пошло не так и как исправить проблему. Сейчас ошибки возвращаются в разных форматах и иногда содержат слишком много технических деталей которые могут раскрывать внутренюю архитектуру системы.

Проблемы текущего подхода:
- Разные форматы ошибок в зависимости от эндпоинта
- Утечка технических деталей (stack traces, SQL запросы)
- Сложность отладки - нет correlation ID для трейсинга запросов
- Не соответствие best practices для REST API

Ограничения:
- Нужна обратная совместимость с существующими клиентами (хотя их пока мало)
- Минимальный overhead на производительность
- Должно работать с FastAPI фреймворком

## Decision

Мы принимаем стандарт **RFC 7807 (Problem Details for HTTP APIs)** для всех ошибок API.

Каждая ошибка будет содержать:
- `type` — URI который идентифицирует тип проблемы (по умолчанию "about:blank")
- `title` — краткое человеко-читаемое описание типа проблемы
- `status` — HTTP статус код
- `detail` — человеко-читаемое объяснение конкретного случая ошибки
- `correlation_id` — уникальный идентификатор запроса для отладки (генерируется автоматически)

Примеры:
```json
{
  "type": "https://api.wishlist.com/errors/validation-failed",
  "title": "Validation Error",
  "status": 400,
  "detail": "Title field is required and cannot be empty",
  "correlation_id": "a3f2b8c9-1234-5678-90ab-cdef12345678"
}
```

Реализация:
- Создаем централизованный обработчик ошибок в `app/middleware/error_handler.py`
- Все исключения перехватываются и преобразуются в RFC 7807 формат
- В production режиме скрываем технические детали, в development показываем больше
- Логируем полную информацию об ошибке с тем же correlation_id

## Alternatives

### Альтернатива 1: Простой JSON с message и code
**Плюсы:**
- Проще в реализации
- Меньше полей

**Минусы:**
- Не стандартизованно
- Нет correlation ID для трейсинга
- Сложнее расширять в будущем

### Альтернатива 2: Использовать только стандартные HTTP статусы без body
**Плюсы:**
- Минимальный трафик
- RESTful подход

**Минусы:**
- Клиенты не получают детальной информации
- Невозможность отладки проблем
- Плохой UX

### Альтернатива 3: GraphQL ошибки
**Плюсы:**
- Хорошо работает с GraphQL
- Структурированные ошибки

**Минусы:**
- Мы используем REST а не GraphQL
- Overhead переключения на другой стандарт

## Consequences

### Плюсы
- **Стандартизация**: RFC 7807 это индустриальный стандарт, клиенты могут использовать готовые библиотеки
- **Улучшенная отладка**: correlation_id позволяет связать ошибку на клиенте с логами на сервере
- **Безопасность**: маскирование технических деталей в production снижает риск утечки информации (закрывает **R10**)
- **Расширяемость**: легко добавлять дополнительные поля при необходимости

### Минусы
- Немного больше payload размер (но не критично, ~100-200 байт)
- Нужно обучить команду новому формату
- Требуется рефакторинг существующих обработчиков ошибок

### Влияние на производительность
- Minimal overhead: ~0.1-0.5мс на создание error response
- Не влияет на happy path
- p95 latency останется в пределах **NFR-03** (≤300мс)

### Security Impact
- **Устранение утечки информации** (связь с **R10** — утечка деталей ошибок)
- Маскирование PII данных в error messages
- correlation_id не содержит чувствительных данных (используем UUID v4)
- В production логе остаются детальные ошибки для аудита (**NFR-10**)

### Trade-offs
- Жертвуем простотой ради стандартизации и безопасности
- Немного больше кода но значительно лучше maintainability

## Rollout Plan

### Фаза 1: Реализация (Неделя 1)
- [ ] Создать `problem()` функцию-helper в `app/utils/errors.py`
- [ ] Добавить middleware для перехвата всех исключений
- [ ] Обновить существующие endpoints для использования нового формата
- [ ] Feature flag `ENABLE_RFC7807` в config для постепенного включения

### Фаза 2: Тестирование (Неделя 2)
- [ ] Unit тесты для всех типов ошибок
- [ ] Integration тесты для проверки формата
- [ ] Проверка что correlation_id правильно логируется

### Фаза 3: Развертывание (Неделя 3)
- [ ] Deploy на staging с feature flag = true
- [ ] Мониторинг error rates и latency
- [ ] Если все ОК — включить на production
- [ ] Обновить документацию API

### Definition of Done (DoD)
- [x] Все endpoints возвращают ошибки в формате RFC 7807
- [x] Correlation ID присутствует во всех error responses
- [x] Технические детали скрыты в production
- [x] Тесты покрывают основные сценарии ошибок
- [x] Документация обновлена

### Мониторинг и метрики
- Отслеживать error rates per endpoint
- Проверять что correlation_id можно найти в логах
- Мониторить latency overhead (должен быть <1мс)

## Links

**NFR (из P03):**
- **NFR-02** — Ошибки в формате RFC7807 (прямое соответствие)
- **NFR-10** — Аудит действий пользователей (логирование с correlation_id)

**STRIDE угрозы (из P04):**
- **F1-F5 (Information Disclosure)** — маскирование технических деталей защищает от утечки информации

**Риски (из P04):**
- **R10** — Утечка деталей ошибок (КРИТЕРИЙ ЗАКРЫТИЯ: Generic error messages + correlation_id для отладки)

**Тесты:**
- `tests/test_errors.py::test_rfc7807_format`
- `tests/test_errors.py::test_correlation_id_present`
- `tests/integration/test_api.py::test_error_responses_rfc7807`

**Связанные ADR:**
- ADR-002 (Rate limiting) — будет использовать RFC7807 для ошибок лимитов
- ADR-004 (Input validation) — будет использовать RFC7807 для валидационных ошибок
