# ADR-003: Управление секретами и ротация ключей

Дата: 2025-01-22  
Статус: Accepted

## Context

В нашем wishlist приложении используются различные секреты которые критичны для безопастности:
- JWT `SECRET_KEY` для подписи токенов
- Database credentials (логин/пароль БД)
- Redis credentials (если есть аутентификация)
- API keys для внешних сервисов (в будущем)

Текущие проблемы:
- Секреты хранятся в `.env` файле который может попасть в git
- Нет процесса ротации секретов
- При компрометации ключа нужно перезапускать все инстансы
- Хардкод значений по умолчанию в `config.py` (наример "your-secret-key-change-in-production")

Требования:
- Секреты не должны попадать в репозиторий
- Должна быть возможность ротации без даунтайма
- Разные секреты для разных окружений (dev/staging/prod)
- Аудит доступа к секретам

Ограничения:
- На текущий момент нет доступа к Vault/AWS Secrets Manager
- Нужно простое решение для MVP
- Должно работать в Docker контейнерах

## Decision

Принимаем **двухуровневый подход** к управлению секретами:

### Уровень 1: Environment Variables (текущий MVP)
Все секреты загружаются из переменных окружения через `os.getenv()` БЕЗ значений по умолчанию.

**Изменения в config.py:**
```python
class Settings:
    # Обязательные секреты - нет дефолтных значений
    SECRET_KEY: str = os.getenv("SECRET_KEY")
    DATABASE_URL: str = os.getenv("DATABASE_URL")
    
    def __post_init__(self):
        # Валидируем что все секреты установлены
        if not self.SECRET_KEY:
            raise ValueError("SECRET_KEY must be set")
        if "change-in-production" in self.SECRET_KEY.lower():
            raise ValueError("Default SECRET_KEY detected!")
```

**Ротация ключей:**
Для JWT поддерживаем 2 ключа одновременно:
- `JWT_SECRET_KEY_CURRENT` — текущий ключ для подписи новых токенов
- `JWT_SECRET_KEY_PREVIOUS` — предыдущий ключ для валидации старых токенов

Процесс ротации:
1. Генерируем новый ключ
2. Устанавливаем его как `PREVIOUS`
3. Старый `CURRENT` → `PREVIOUS`, новый → `CURRENT`
4. Rolling restart приложения
5. Через TTL токенов (30 мин) удаляем `PREVIOUS`

### Уровень 2: Secrets Manager (будущее)
Когда инфраструктура позволит переходим на HashiCorp Vault или AWS Secrets Manager:
- Централизованное хранение
- Автоматическая ротация
- Аудит логи доступа
- Fine-grained access control

### Правила работы с секретами:

1. **Никогда не коммитить** секреты в git
   - Добавить `.env*` в `.gitignore`
   - Pre-commit hook для проверки секретов

2. **Никогда не логировать** секреты
   - Маскировать в логах (показывать только первые 4 символа)
   - Исключить из error messages (RFC7807)

3. **Генерация секретов** должна быть криптографически стойкой
   ```python
   import secrets
   secret_key = secrets.token_urlsafe(32)  # 256 bits
   ```

4. **Валидация** при старте приложения
   - Проверка что секреты установлены
   - Проверка минимальной длины (≥32 байта для JWT)
   - Проверка что не используются дефолтные значения

## Alternatives

### Альтернатива 1: Хранить секреты в git в encrypted виде (git-crypt, SOPS)
**Плюсы:**
- Version control для секретов
- Легко откатиться к предыдущим версиям
- Нет зависимости от внешних сервисов

**Минусы:**
- Все с доступом к репо могут расшифровать
- Сложность управления ключами шифрования
- Риск случайного коммита расшифрованных файлов

**Вердикт:** Слишком рискованно для продакшена

### Альтернатива 2: Kubernetes Secrets
**Плюсы:**
- Нативная интеграция с k8s
- RBAC для доступа
- Автоматический mount в pods

**Минусы:**
- Мы не используем Kubernetes (пока)
- Секреты хранятся в etcd в base64 (не encrypted по умолчанию)

**Вердикт:** Хороший вариант когда перейдем на k8s

### Альтернатива 3: Hardcode секреты с обфускацией
**Плюсы:**
- Нет внешних зависимостей
- Работает везде

**Минусы:**
- КРАЙНЕ ОПАСНО
- Обфускация != шифрование
- Невозможность ротации без релиза

**Вердикт:** Категорически отвергнута

### Альтернатива 4: Config server (Spring Cloud Config)
**Плюсы:**
- Централизованная конфигурация
- Поддержка multiple окружений
- Dynamic refresh

**Минусы:**
- Мы не используем Java/Spring
- Дополнительный сервис для поддержки

**Вердикт:** Overkill для нашего размера

## Consequences

### Плюсы
- **Безопасность**: секреты не попадут в git (**R3** — компрометация JWT ключа)
- **Flexibility**: легко менять секреты для разных окружений
- **Ротация**: поддержка 2 ключей позволяет zero-downtime rotation
- **Compliance**: соответствие security best practices

### Минусы
- **Сложность deployment**: нужно настраивать env vars в каждом окружении
- **Нет централизации**: каждый сервис управляет своими секретами
- **Человеческий фактор**: можно случайно забыть установить секрет

### Влияние на производительность
- Нулевое влияние на runtime (секреты читаются 1 раз при старте)
- Немного медленнее startup если валидируем секреты

### Security Impact
- **Снижение риска R3** (компрометация JWT) с уровня 10 до ~4 (Risk = 1×4 = 4)
  - Likelihood уменьшается с 2 до 1 благодаря отсутствию в git
  - Impact остается 5 (критический) но процесс ротации минимизирует урон
- **Снижение риска R10** (утечка деталей) — секреты не попадают в error messages
- Защита от **F6 (T,I) — JWT Manager threats**

### Developer Experience
- Нужно создавать `.env` файлы локально (предоставим `.env.example`)
- Четкая документация как генерировать и устанавливать секреты
- Startup validation сразу покажет если секрет не установлен

### Trade-offs
- Жертвуем простотой настройки ради безопасности
- Двухключевая ротация сложнее но позволяет zero-downtime
- Environment variables не идеальны но достаточны для MVP

## Rollout Plan

### Фаза 1: Code Changes (Неделя 1)
- [ ] Обновить `app/core/config.py`:
  - Удалить дефолтные значения для SECRET_KEY
  - Добавить валидацию секретов в `__post_init__`
  - Добавить поддержку CURRENT/PREVIOUS ключей
- [ ] Обновить `app/core/auth.py`:
  - Поддержка валидации токенов с двумя ключами
  - Подпись только с CURRENT ключом
- [ ] Создать `.env.example` с примерами
- [ ] Добавить генератор секретов: `scripts/generate_secrets.py`

### Фаза 2: Git Protection (Неделя 1)
- [ ] Обновить `.gitignore`:
  ```
  .env
  .env.local
  .env.*.local
  *.key
  *.pem
  secrets/
  ```
- [ ] Добавить pre-commit hook для detect-secrets
- [ ] Audit существующих коммитов на наличие секретов

### Фаза 3: Documentation (Неделя 1-2)
- [ ] Документировать процесс генерации секретов
- [ ] Создать runbook для ротации ключей
- [ ] Обновить README с инструкциями по настройке
- [ ] Security policy для работы с секретами

### Фаза 4: Testing (Неделя 2)
- [ ] Unit тесты для валидации секретов при старте
- [ ] Integration тесты для JWT с двумя ключами
- [ ] Negative тесты: старт без секретов должен упасть

### Фаза 5: Deployment (Неделя 2-3)
- [ ] Сгенерировать production секреты
- [ ] Настроить env vars в hosting platform
- [ ] Deploy с новой конфигурацией
- [ ] Проверить что все работает

### Фаза 6: Ротация Schedule (Ongoing)
- [ ] Настроить календарь ротации (каждые 30 дней согласно **NFR-05**)
- [ ] Создать алерт за 7 дней до истечения срока
- [ ] Automated reminder в Slack/Email

### Definition of Done (DoD)
- [x] Секреты загружаются только из env variables
- [x] Нет дефолтных значений в коде
- [x] Валидация при старте приложения
- [x] Поддержка 2 JWT ключей для ротации
- [x] `.env` файлы в `.gitignore`
- [x] Pre-commit hook для detect-secrets
- [x] Документация процесса ротации
- [x] Тесты покрывают основные сценарии

### Критерии ротации (согласно NFR-05)
- Ротация каждые **30 дней** (плановая)
- Немедленная ротация при подозрении на компрометацию
- Журнал ротаций в отдельном логе с timestamp и автором

## Links

**NFR (из P03):**
- **NFR-05** — Ротация секретов (прямое соответствие, порог: раз в 30 дней)
- **NFR-04** — Уязвимости зависимостей (detect-secrets как dependency)

**STRIDE угрозы (из P04):**
- **F6: JWT Manager (T)** — защита от манипуляции токенами
- **F6: JWT Manager (I)** — защита от разглашения секретного ключа
- **F1-F5 (I)** — секреты не логируются и не попадают в error messages

**Риски (из P04):**
- **R3** — Компрометация JWT секретного ключа (КРИТЕРИЙ ЗАКРЫТИЯ: Key rotation policy + secure storage)
- **R10** — Утечка деталей ошибок (секреты не в error responses)

**Тесты:**
- `tests/unit/test_config.py::test_secrets_validation`
- `tests/unit/test_config.py::test_no_default_secrets`
- `tests/integration/test_auth.py::test_jwt_with_two_keys`
- `tests/nfr/test_security.py::test_secrets_not_in_logs`

**Связанные ADR:**
- ADR-001 (RFC7807) — секреты не должны попадать в error responses
- ADR-002 (Rate Limiting) — Redis credentials как пример секрета

